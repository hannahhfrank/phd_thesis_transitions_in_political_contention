import pandas as pdimport osimport numpy as npfrom functions import lag_groupped,apply_decay,dichotomize,consec_zeros_grouped,imp_opti,calibrate_imp,get_wb,multivariate_imp_bayes,multivariate_imp_tree,multivariate_imp_neigh,simple_imp_grouped,linear_imp_groupedimport matplotlib.pyplot as pltimport statsmodels.api as smimport pyreadstat################################ Data for simple model ################################# List of microstates: micro_states={"Dominica":54,              "Grenada":55,              "Saint Lucia":56,              "Saint Vincent and the Grenadines":57,              "Antigua & Barbuda":58,              "Saint Kitts and Nevis":60,              "Monaco":221,              "Liechtenstein":223,              "San Marino":331,              "Andorra":232,              "Abkhazia":396,              "South Ossetia":397,              "São Tomé and Principe":403,              "Seychelles":591,              "Vanuatu":935,              "Kiribati":970,              "Nauru":971,              "Tonga":972,              "Tuvalu":973,              "Marshall Islands":983,              "Palau":986,              "Micronesia":987,              "Samoa":990}# Additional countries not included in ACLED: # 265 German Democratic Republic	# 315 Czechoslovakia# 345 Yugoslavia# 396 Abkhazia# 397 South Ossetia# 680 Yemen, People's Republic of ---> EXCLUDE# Temporal coverage: 1989--2022exclude={"German Democratic Republic":265,         "Czechoslovakia":315,         "Yugoslavia":345,         "Abkhazia":396,         "South Ossetia":397,         "Yemen, People's Republic of":680}# Countries not included in World Bank: # Or have mostly missing values    exclude2 ={"Taiwan":713, # Not included in WDI           "Bahamas":31, # Not included in vdem           "Belize":80, # Not included in vdem           "Brunei Darussalam":835, # Not included in vdem           "Kosovo":347, # Mostly missing in WDI           "Democratic Peoples Republic of Korea":731} # Mostly missing in WDI############### UCDP ###############ucdp_sb=pd.read_csv("data/data_out/ucdp_cy_sb.csv",index_col=0)df = ucdp_sb[["year","gw_codes","country","best"]][~ucdp_sb['gw_codes'].isin(list(micro_states.values())+list(exclude.values())+list(exclude2.values()))]df.columns=["year","gw_codes","country","sb_fatalities"]# A. t-1 model df["sb_fatalities_lag1"]=lag_groupped(df,"country","sb_fatalities",1)# B. Time sincedichotomize(df,"sb_fatalities","d_civil_war",1000)dichotomize(df,"sb_fatalities","d_civil_conflict",25)df['d_civil_conflict_zeros'] = consec_zeros_grouped(df,'country','d_civil_conflict')df['d_civil_conflict_zeros_decay'] = apply_decay(df,'d_civil_conflict_zeros')df = df.drop('d_civil_conflict', axis=1)df = df.drop('d_civil_conflict_zeros', axis=1)df['d_civil_war_zeros'] = consec_zeros_grouped(df,'country','d_civil_war')df['d_civil_war_zeros_decay'] = apply_decay(df,'d_civil_war_zeros')df = df.drop('d_civil_war', axis=1)df = df.drop('d_civil_war_zeros', axis=1)#def lag_groupped_ts(df, group_var, var, lag):#    return df.groupby(group_var)[var].shift(lag).fillna(35)#grouped = df.groupby('gw_codes')['d_civil_conflict'].apply(lambda x: measure_time_since_last_civil_war(x))#df["time_since_civil_conflict"] = [item for sublist in grouped for item in sublist]#df.loc[df["time_since_civil_conflict"]==-1,"time_since_civil_conflict"]=35#df["time_since_civil_conflict_lag1"]=lag_groupped_ts(df,"country","time_since_civil_conflict",1)#df = df.drop('d_civil_conflict', axis=1)#df = df.drop('time_since_civil_conflict', axis=1)#dichotomize(df,"sb_fatalities","d_civil_war",1000)#grouped = df.groupby('gw_codes')['d_civil_war'].apply(lambda x: measure_time_since_last_civil_war(x))#df["time_since_civil_war"] = [item for sublist in grouped for item in sublist]#df.loc[df["time_since_civil_war"]==-1,"time_since_civil_war"]=35#df["time_since_civil_war_lag1"]=lag_groupped_ts(df,"country","time_since_civil_war",1)#df['time_since_civil_war_decay'] = apply_decay(df,'time_since_civil_war_lag1')#df = df.drop('d_civil_war', axis=1)#df = df.drop('time_since_civil_war', axis=1)# C. Neighbor conflict history sb fatalities neighbors=pd.read_csv("data/data_out/cy_neighbors.csv",index_col=0)gw_codes=pd.read_csv("data/df_ccodes_gw.csv")gw_codes_s=gw_codes.loc[gw_codes["end"]>=1989]df_neighbors=pd.merge(left=df[["year","country","gw_codes","sb_fatalities"]],right=neighbors[["gw_codes","year","neighbors"]],on=["year","gw_codes"],how="left")df_neighbors["neighbors_fat"]=0for i in range(len(df_neighbors)):    if pd.isna(df_neighbors["neighbors"].iloc[i]):         pass    else:           lst=df_neighbors["neighbors"].iloc[i].split(';')        counts=0        for x in lst:            c=int(gw_codes_s["gw_codes"].loc[gw_codes_s["country"]==x].iloc[0])            if df_neighbors["sb_fatalities"].loc[(df_neighbors["year"]==df_neighbors["year"].iloc[i])&(df_neighbors["gw_codes"]==c)].empty==False:                counts+=int(df_neighbors["sb_fatalities"].loc[(df_neighbors["year"]==df_neighbors["year"].iloc[i])&(df_neighbors["gw_codes"]==c)].iloc[0])        if counts>0:            df_neighbors.iloc[i, df_neighbors.columns.get_loc('neighbors_fat')] = countsdichotomize(df_neighbors,"neighbors_fat","d_neighbors_sb_fatalities",0)df_neighbors['d_neighbors_sb_fatalities_lag1'] = lag_groupped(df_neighbors,'country','d_neighbors_sb_fatalities',1)df=pd.merge(left=df,right=df_neighbors[["year","gw_codes","d_neighbors_sb_fatalities_lag1"]],on=["year","gw_codes"],how="left")########################## World Bank data ##########################df_econ=df[["year","gw_codes","country"]].copy()feat_dev = ["NY.GDP.PCAP.CD", # GDP per capita (current US$)            "NY.GDP.MKTP.KD.ZG", # GDP growth (annual %)             "NY.GDP.PETR.RT.ZS", # Oil rents (% of GDP)            "SP.POP.TOTL", # Population size            "SP.DYN.IMRT.IN", # Mortality rate, infant (per 1,000 live births)            'SP.POP.2024.MA.5Y', # Population ages 20-24, male (% of male population)            "ER.H2O.FWTL.ZS", # Annual freshwater withdrawals, total (% of internal resources)                      ]# Import country codes  df_ccodes = pd.read_csv("data/df_ccodes.csv")c_list=list(df_ccodes.iso_alpha3)c_list = [char for char in c_list if char != "XYZ"]# Load data economy=get_wb(list(range(1989, 2023, 1)),c_list,feat_dev,"wb_inter")# A. GDP per capita # Mergebase=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=economy[["year","gw_codes","NY.GDP.PCAP.CD","NY.GDP.MKTP.KD.ZG","SP.POP.TOTL","NY.GDP.PETR.RT.ZS","SP.DYN.IMRT.IN",'SP.POP.2024.MA.5Y',"ER.H2O.FWTL.ZS"]],on=["year","gw_codes"],how="left")### Multiple ###base_imp=imp_opti(base,"country",["NY.GDP.PCAP.CD"],vars_add=["NY.GDP.MKTP.KD.ZG","NY.GDP.PETR.RT.ZS"],max_iter=10)# Calibrate base_imp_calib=calibrate_imp(base_imp, "country", "NY.GDP.PCAP.CD")### Simple ###base_imp_final=linear_imp_grouped(base,"country",["NY.GDP.PCAP.CD"])base_imp_final=simple_imp_grouped(base_imp_final,"country",["NY.GDP.PCAP.CD"])# Mergebase_imp_final["NY.GDP.PCAP.CD"] = base_imp_final["NY.GDP.PCAP.CD"].fillna(base_imp_calib["NY.GDP.PCAP.CD"])base_imp_final = base_imp_final.rename(columns={"NY.GDP.PCAP.CD": 'gdp'})# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["NY.GDP.PCAP.CD"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["gdp"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Mergedf=pd.merge(left=df,right=base_imp_final[["year","gw_codes","gdp"]],on=["year","gw_codes"],how="left")# B. GDP growth (annual %) # Mergebase=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=economy[["year","gw_codes","NY.GDP.PCAP.CD","NY.GDP.MKTP.KD.ZG","SP.POP.TOTL","NY.GDP.PETR.RT.ZS","SP.DYN.IMRT.IN",'SP.POP.2024.MA.5Y',"ER.H2O.FWTL.ZS"]],on=["year","gw_codes"],how="left")### Multiple ###base_imp=imp_opti(base,"country",["NY.GDP.MKTP.KD.ZG"],vars_add=["NY.GDP.PCAP.CD","NY.GDP.PETR.RT.ZS"],max_iter=10)# Calibrate base_imp_calib=calibrate_imp(base_imp, "country", "NY.GDP.MKTP.KD.ZG")### Simple ###base_imp_final=linear_imp_grouped(base,"country",["NY.GDP.MKTP.KD.ZG"])base_imp_final=simple_imp_grouped(base_imp_final,"country",["NY.GDP.MKTP.KD.ZG"])# Mergebase_imp_final["NY.GDP.MKTP.KD.ZG"] = base_imp_final["NY.GDP.MKTP.KD.ZG"].fillna(base_imp_calib["NY.GDP.MKTP.KD.ZG"])base_imp_final = base_imp_final.rename(columns={"NY.GDP.MKTP.KD.ZG": 'growth'})# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["NY.GDP.MKTP.KD.ZG"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["growth"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Mergedf=pd.merge(left=df,right=base_imp_final[["year","gw_codes","growth"]],on=["year","gw_codes"],how="left")# C. Oil rents (% of GDP)# Mergebase=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=economy[["year","gw_codes","NY.GDP.PCAP.CD","NY.GDP.MKTP.KD.ZG","SP.POP.TOTL","NY.GDP.PETR.RT.ZS","SP.DYN.IMRT.IN",'SP.POP.2024.MA.5Y',"ER.H2O.FWTL.ZS"]],on=["year","gw_codes"],how="left")### Multiple ###base_imp=imp_opti(base,"country",["NY.GDP.PETR.RT.ZS"],vars_add=["NY.GDP.PCAP.CD","NY.GDP.MKTP.KD.ZG"],max_iter=10)# Calibrate base_imp_calib=calibrate_imp(base_imp, "country", "NY.GDP.PETR.RT.ZS")### Simple ###base_imp_final=linear_imp_grouped(base,"country",["NY.GDP.PETR.RT.ZS"])base_imp_final=simple_imp_grouped(base_imp_final,"country",["NY.GDP.PETR.RT.ZS"])# Mergebase_imp_final["NY.GDP.PETR.RT.ZS"] = base_imp_final["NY.GDP.PETR.RT.ZS"].fillna(base_imp_calib["NY.GDP.PETR.RT.ZS"])base_imp_final = base_imp_final.rename(columns={"NY.GDP.PETR.RT.ZS": 'oil_share'})# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["NY.GDP.PETR.RT.ZS"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["oil_share"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Mergedf=pd.merge(left=df,right=base_imp_final[["year","gw_codes","oil_share"]],on=["year","gw_codes"],how="left")# D. Population size# Mergebase=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=economy[["year","gw_codes","NY.GDP.PCAP.CD","NY.GDP.MKTP.KD.ZG","SP.POP.TOTL","NY.GDP.PETR.RT.ZS","SP.DYN.IMRT.IN",'SP.POP.2024.MA.5Y',"ER.H2O.FWTL.ZS"]],on=["year","gw_codes"],how="left")### Multiple ###base_imp=imp_opti(base,"country",["SP.POP.TOTL"],vars_add=["SP.DYN.IMRT.IN",'SP.POP.2024.MA.5Y'],max_iter=10)# Calibrate base_imp_calib=calibrate_imp(base_imp, "country", "SP.POP.TOTL")### Simple ###base_imp_final=linear_imp_grouped(base,"country",["SP.POP.TOTL"])base_imp_final=simple_imp_grouped(base_imp_final,"country",["SP.POP.TOTL"])# Mergebase_imp_final["SP.POP.TOTL"] = base_imp_final["SP.POP.TOTL"].fillna(base_imp_calib["SP.POP.TOTL"])base_imp_final = base_imp_final.rename(columns={"SP.POP.TOTL": 'pop'})# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["SP.POP.TOTL"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["pop"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Mergedf=pd.merge(left=df,right=base_imp_final[["year","gw_codes","pop"]],on=["year","gw_codes"],how="left")# E. Mortality rate, infant (per 1,000 live births)# Mergebase=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=economy[["year","gw_codes","NY.GDP.PCAP.CD","NY.GDP.MKTP.KD.ZG","SP.POP.TOTL","NY.GDP.PETR.RT.ZS","SP.DYN.IMRT.IN",'SP.POP.2024.MA.5Y',"ER.H2O.FWTL.ZS"]],on=["year","gw_codes"],how="left")### Multiple ###base_imp=imp_opti(base,"country",["SP.DYN.IMRT.IN"],vars_add=["SP.POP.TOTL",'SP.POP.2024.MA.5Y'],max_iter=10)# Calibrate base_imp_calib=calibrate_imp(base_imp, "country", "SP.DYN.IMRT.IN")### Simple ###base_imp_final=linear_imp_grouped(base,"country",["SP.DYN.IMRT.IN"])base_imp_final=simple_imp_grouped(base_imp_final,"country",["SP.DYN.IMRT.IN"])# Mergebase_imp_final["SP.DYN.IMRT.IN"] = base_imp_final["SP.DYN.IMRT.IN"].fillna(base_imp_calib["SP.DYN.IMRT.IN"])base_imp_final = base_imp_final.rename(columns={"SP.DYN.IMRT.IN": 'inf_mort'})# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["SP.DYN.IMRT.IN"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["inf_mort"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Mergedf=pd.merge(left=df,right=base_imp_final[["year","gw_codes","inf_mort"]],on=["year","gw_codes"],how="left")# F. Male total population 15-19# Mergebase=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=economy[["year","gw_codes","NY.GDP.PCAP.CD","NY.GDP.MKTP.KD.ZG","SP.POP.TOTL","NY.GDP.PETR.RT.ZS","SP.DYN.IMRT.IN",'SP.POP.2024.MA.5Y',"ER.H2O.FWTL.ZS"]],on=["year","gw_codes"],how="left")### Multiple ###base_imp=imp_opti(base,"country",["SP.POP.2024.MA.5Y"],vars_add=["SP.DYN.IMRT.IN",'SP.POP.TOTL'],max_iter=10)# Calibrate base_imp_calib=calibrate_imp(base_imp, "country", "SP.POP.2024.MA.5Y")### Simple ###base_imp_final=linear_imp_grouped(base,"country",["SP.POP.2024.MA.5Y"])base_imp_final=simple_imp_grouped(base_imp_final,"country",["SP.POP.2024.MA.5Y"])# Mergebase_imp_final["SP.POP.2024.MA.5Y"] = base_imp_final["SP.POP.2024.MA.5Y"].fillna(base_imp_calib["SP.POP.2024.MA.5Y"])base_imp_final = base_imp_final.rename(columns={"SP.POP.2024.MA.5Y": 'male_youth_share'})# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["SP.POP.2024.MA.5Y"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["male_youth_share"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Mergedf=pd.merge(left=df,right=base_imp_final[["year","gw_codes","male_youth_share"]],on=["year","gw_codes"],how="left")# G. Average Mean Surface Air Temperature # Mergetemp=pd.read_csv("/Users/hannahfrank/phd_thesis_transitions_pol_contention/data/data_out/temp_cy.csv",index_col=0)base=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=economy[["year","gw_codes","NY.GDP.PCAP.CD","NY.GDP.MKTP.KD.ZG","SP.POP.TOTL","NY.GDP.PETR.RT.ZS","SP.DYN.IMRT.IN",'SP.POP.2024.MA.5Y',"ER.H2O.FWTL.ZS"]],on=["year","gw_codes"],how="left")base=pd.merge(left=base,right=temp[["gw_codes","year","temp"]],on=["year","gw_codes"],how="left")### Multiple ###base_imp=imp_opti(base,"country",["temp"],vars_add=["ER.H2O.FWTL.ZS"],max_iter=10)# Calibrate base_imp_calib=calibrate_imp(base_imp, "country", "temp")### Simple ###base_imp_final=linear_imp_grouped(base,"country",["temp"])base_imp_final=simple_imp_grouped(base_imp_final,"country",["temp"])# Mergebase_imp_final["temp"] = base_imp_final["temp"].fillna(base_imp_calib["temp"])# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["temp"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["temp"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Mergedf=pd.merge(left=df,right=base_imp_final[["year","gw_codes","temp"]],on=["year","gw_codes"],how="left")# H. Annual freshwater withdrawals, total (% of internal resources)  # Mergetemp=pd.read_csv("data/data_out/temp_cy.csv",index_col=0)base=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=temp[["year","gw_codes","temp"]],on=["year","gw_codes"],how="left")base=pd.merge(left=base,right=economy[["year","gw_codes","NY.GDP.PCAP.CD","NY.GDP.MKTP.KD.ZG","SP.POP.TOTL","NY.GDP.PETR.RT.ZS","SP.DYN.IMRT.IN",'SP.POP.2024.MA.5Y',"ER.H2O.FWTL.ZS"]],on=["year","gw_codes"],how="left")### Multiple ###base_imp=imp_opti(base,"country",["ER.H2O.FWTL.ZS"],vars_add=["temp"],max_iter=10)# Calibrate base_imp_calib=calibrate_imp(base_imp, "country", "ER.H2O.FWTL.ZS")### Simple ###base_imp_final=linear_imp_grouped(base,"country",["ER.H2O.FWTL.ZS"])base_imp_final=simple_imp_grouped(base_imp_final,"country",["ER.H2O.FWTL.ZS"])# Mergebase_imp_final["ER.H2O.FWTL.ZS"] = base_imp_final["ER.H2O.FWTL.ZS"].fillna(base_imp_calib["ER.H2O.FWTL.ZS"])base_imp_final = base_imp_final.rename(columns={"ER.H2O.FWTL.ZS": 'withdrawl'})# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["ER.H2O.FWTL.ZS"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["withdrawl"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show() # Mergedf=pd.merge(left=df,right=base_imp_final[["year","gw_codes","withdrawl"]],on=["year","gw_codes"],how="left")############## EPR ############### A. Ethnic fractionalizationbase=df[["year","gw_codes","country"]].copy()erp=pd.read_csv("data/data_out/epr_cy.csv",index_col=0)base=pd.merge(left=base,right=erp[["year","gw_codes","ethnic_frac"]],on=["year","gw_codes"],how="left")### Simple ###base_imp_final=linear_imp_grouped(base,"country",["ethnic_frac"])base_imp_final=simple_imp_grouped(base_imp_final,"country",["ethnic_frac"])# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["ethnic_frac"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["ethnic_frac"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()df=pd.merge(left=df,right=base_imp_final[["year","gw_codes","ethnic_frac"]],on=["year","gw_codes"],how="left")############### UNDP ################ A. Expected years of schooling, male# Mergehdi=pd.read_csv("/Users/hannahfrank/phd_thesis_transitions_pol_contention/data/data_out/hdi_cy.csv",index_col=0)base=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=hdi[["year","gw_codes",'eys','eys_male','eys_female','mys','mys_male','mys_female']],on=["year","gw_codes"],how="left")### Multiple ###base_imp=imp_opti(base,"country",["eys_male"],vars_add=['eys','eys_female'],max_iter=10)# Calibrate base_imp_calib=calibrate_imp(base_imp, "country","eys_male")### Simple ###base_imp_final=linear_imp_grouped(base,"country",["eys_male"])base_imp_final=simple_imp_grouped(base_imp_final,"country",["eys_male"])# Mergebase_imp_final["eys_male"] = base_imp_final["eys_male"].fillna(base_imp_calib["eys_male"])base_imp_final['eys_male_id'] = base_imp["missing_id"]# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["eys_male"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["eys_male"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Mergedf=pd.merge(left=df,right=base_imp_final[["year","gw_codes","eys_male"]],on=["year","gw_codes"],how="left")################ V-Dem ################# A. Electoral democracy index # Mergevdem=pd.read_csv("data/data_out/vdem_cy.csv",index_col=0)df=pd.merge(left=df,right=vdem[["year","gw_codes","v2x_polyarchy"]],on=["year","gw_codes"],how="left")df = df.rename(columns={"v2x_polyarchy": 'polyarchy'})# B. Liberal democracy index# Mergevdem=pd.read_csv("data/data_out/vdem_cy.csv",index_col=0)base=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=vdem[["year","gw_codes","v2x_polyarchy","v2x_libdem","v2x_egaldem","v2x_civlib","v2xpe_exlsocgr"]],on=["year","gw_codes"],how="left")### Multiple ###base_imp=imp_opti(base,"country",["v2x_libdem"],vars_add=["v2x_polyarchy","v2x_egaldem","v2x_civlib","v2xpe_exlsocgr"],max_iter=10)# Calibrate base_imp_calib=calibrate_imp(base_imp, "country","v2x_libdem")### Simple ###base_imp_final=linear_imp_grouped(base,"country",["v2x_libdem"])base_imp_final=simple_imp_grouped(base_imp_final,"country",["v2x_libdem"])# Mergebase_imp_final["v2x_libdem"] = base_imp_final["v2x_libdem"].fillna(base_imp_calib["v2x_libdem"])base_imp_final = base_imp_final.rename(columns={"v2x_libdem": 'libdem'})# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["v2x_libdem"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["libdem"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Mergedf=pd.merge(left=df,right=base_imp_final[["year","gw_codes","libdem"]],on=["year","gw_codes"],how="left")# C. Egalitarian democracy index  # Mergevdem=pd.read_csv("data/data_out/vdem_cy.csv",index_col=0)df=pd.merge(left=df,right=vdem[["year","gw_codes","v2x_egaldem"]],on=["year","gw_codes"],how="left")df = df.rename(columns={"v2x_egaldem": 'egaldem'})# D. Civil liberties index  # Mergevdem=pd.read_csv("data/data_out/vdem_cy.csv",index_col=0)df=pd.merge(left=df,right=vdem[["year","gw_codes","v2x_civlib"]],on=["year","gw_codes"],how="left")df = df.rename(columns={"v2x_civlib": 'civlib'})# E. Exclusion by Social Group index# Mergevdem=pd.read_csv("data/data_out/vdem_cy.csv",index_col=0)base=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=vdem[["year","gw_codes","v2x_polyarchy","v2x_libdem","v2x_egaldem","v2x_civlib","v2xpe_exlsocgr"]],on=["year","gw_codes"],how="left")### Multiple ###base_imp=imp_opti(base,"country",["v2xpe_exlsocgr"],vars_add=["v2x_polyarchy","v2x_libdem","v2x_egaldem","v2x_civlib"],max_iter=10)# Calibrate base_imp_calib=calibrate_imp(base_imp, "country","v2xpe_exlsocgr")### Simple ###base_imp_final=linear_imp_grouped(base,"country",["v2xpe_exlsocgr"])base_imp_final=simple_imp_grouped(base_imp_final,"country",["v2xpe_exlsocgr"])# Mergebase_imp_final["v2xpe_exlsocgr"] = base_imp_final["v2xpe_exlsocgr"].fillna(base_imp_calib["v2xpe_exlsocgr"])base_imp_final = base_imp_final.rename(columns={"v2xpe_exlsocgr": 'exlsocgr'})# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["v2xpe_exlsocgr"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["exlsocgr"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Mergedf=pd.merge(left=df,right=base_imp_final[["year","gw_codes","exlsocgr"]],on=["year","gw_codes"],how="left")# Save print(df.isnull().any())df.to_csv("data/data_out/df_interpret.csv")############################### Data for Replication ################################## (A) Greed and Grievance in Civil War -------------------------ch = pd.read_stata('data/G&G.dta')ch=ch[["country","year","warsa","coldwar","prevwara","peace","elfo","rf","frac","geogia","mount","lnpop","sxp","sxp2","dem","lngdp_","gy1","secm","pol16","etdo4590","ygini"]]ch = ch.dropna()ch.isnull().any()ch.to_csv("data/data_out/ch.csv")#'country'#'year'#'warsa' --> War onset#'coldwar' --> Post-coldwar#'prevwara' --> Previous war#'peace' --> Peace duration#'elfo' --> Ethnic fractionalization#'rf' --> Religious fractionalization#'frac' --> Social fractionalization#'geogia' --> Geographic dispersion#'mount' --> Mountainous terrain#'lnpop' --> Ln population#'sxp' --> Primary commodity exports/GDP#'sxp2' --> Primary commodity exports/GDP)2#'dem' --> Democracy #'lngdp_' --> Ln GDP per capita #'gy1' --> GDP growth#'secm' --> Male secondary schooling#'pol16' --> Polarization a = 1.6#'etdo4590' --> Ethnic dominance (45-90%)#'ygini' --> Income inequality#'oilsxp' --> Primary commodity exports/GDP*oil dummy#'oilsxp2' --> (Primary commodity exports/GDP)2*oil dummy#'grievxb' --> Grievance predicted value#'greedxb' --> Opportunity predicted value#'diaspeaa' --> Diaspora/peace#'difdpeaa' --> Diaspora corrected/peace#'diahpeaa' --> (Diaspora-diaspora corrected)/peace#'lgini' --> Land inequality#'id'#'pwtid'# Model I OpportunityX=ch[["sxp","sxp2","coldwar","secm","gy1","peace","prevwara","mount","geogia","frac","lnpop"]]X = sm.add_constant(X)y=ch[['warsa']]est1 = sm.OLS(y, X).fit()est1.summary()# Model II GrievancesX=ch[["elfo","rf","pol16","etdo4590","dem","peace","mount","geogia","lnpop"]]X = sm.add_constant(X)y=ch[['warsa']]est2 = sm.OLS(y, X).fit()est2.summary()# Model III Combined modelX=ch[["sxp","sxp2","coldwar","secm","gy1","peace","mount","geogia","lnpop","frac","elfo","rf","pol16","etdo4590","dem"]]X = sm.add_constant(X)y=ch[['warsa']]est3 = sm.OLS(y, X).fit()est3.summary()### (B) Ethnicity, Insurgency, and Civil War -----------------------fl, meta = pyreadstat.read_dta('data/repdata.dta')fl=fl[["country","year","onset","warl","gdpenl","lpopl1","lmtnest","ncontig","Oil","nwstate","instab","polity2l","ethfrac","relfrac"]]fl = fl.dropna()fl.isnull().any()fl.loc[fl["onset"]==4,"onset"]=1fl.to_csv("data/data_out/fl.csv")#'country'#'year'#'onset' --> War onset#'warl' --> Prior war#'gdpenl' --> Per capita income #'lpopl1' -->log(population)#'lmtnest' --> log(% mountainous)#'ncontig' --> Noncontiguous state#'Oil' --> Oil exporter#'nwstate' --> New state#'instab' --> Instability#'polity2l' --> Democracy#'ethfrac' --> Ethnic fractionalization #'relfrac' --> Religious fractionalization#'lgdpenl1'#'ccode'#'cname'#'cmark'#'wars'#'war' #'ethonset'#'durest'#'aim'#'casename'#'ended'#'ethwar'#'waryrs'#'pop'#'lpop'#'polity2'#'gdpen'#'gdptype'#'region'#'western'#'eeurop'#'lamerica'#'ssafrica'#'asia'#'nafrme'#'colbrit'#'colfra'#'mtnest'#'elevdiff'#'ef'#'plural'#'second'#'numlang'#'plurrel'#'minrelpc'#'muslim'#'anocl'#'deml'#'empethfrac'#'empwarl'#'emponset'#'empgdpenl'#'emplpopl'#'emplmtnest'#'empncontig'#'empolity2l'#'sdwars'#'sdonset'#'colwars'#'colonset'#'cowwars'#'cowonset'#'cowwarl'#'sdwarl'#'colwarl'# Model I X=fl[["warl","gdpenl","lpopl1","lmtnest","ncontig","Oil","nwstate","instab","polity2l","ethfrac","relfrac"]]X = sm.add_constant(X)y=fl[['onset']]est1 = sm.OLS(y, X).fit()est1.summary()       ### (C) Ethnic Politics and Armed Conflict: A Configurational Analysis of a New Global Data Set -----------------### Why do ethnic groups rebel? New data and analysis ---> no replication### Horizontal inequalities and ethnonationalist civil war: A global comparison ---> no replicationwcm = pd.read_stata('data/EPR3CountryNewReduced.dta')wcm=wcm[["country","year","newonset","lrexclpop","egipgrps","pimppast",'ethfrac',"gdpcapl","lpopl",'lmtnest','regchg3','anocl','oilpcl',"ongoingwarl","npeaceyears","nspline1","nspline2","nspline3"]]wcm = wcm.dropna()wcm.isnull().any()wcm['year'] = wcm['year'].dt.yeardummies_c = pd.get_dummies(wcm['year'], prefix='y').astype(int)wcm = pd.concat([wcm, dummies_c], axis=1)wcm.to_csv("data/data_out/wcm.csv")# Model I years=['y_1947','y_1948','y_1949','y_1950','y_1951','y_1952','y_1953','y_1954','y_1955','y_1956','y_1957','y_1958','y_1959','y_1960','y_1961','y_1962','y_1963','y_1964','y_1965','y_1966','y_1967','y_1968','y_1969','y_1970','y_1971','y_1972','y_1973','y_1974','y_1975','y_1976','y_1977','y_1978','y_1979','y_1980','y_1981','y_1982','y_1983','y_1984','y_1985','y_1986','y_1987','y_1988','y_1989','y_1990','y_1991','y_1992','y_1993','y_1994','y_1995','y_1996','y_1997','y_1998','y_1999','y_2000','y_2001','y_2002','y_2003','y_2004','y_2005','y_2006','y_2007','y_2008','y_2009','y_2010']X=wcm[["lrexclpop","egipgrps","pimppast",'ethfrac',"gdpcapl","lpopl",'lmtnest','regchg3','anocl','oilpcl',"ongoingwarl","npeaceyears","nspline1","nspline2","nspline3"]+years]X = sm.add_constant(X)y=wcm[['newonset']]est1 = sm.OLS(y, X)est1 = est1.fit(cov_type='cluster', cov_kwds={'groups': wcm['country']})est1.summary()#'year'#'country' #'newonset' ---> Conflict onset#'newonset2' ---> Drop ongoing conflict#'lrexclpop' ---> Excluded population#'egipgrps' ---> Center segmentation#'pimppast' ---> Imperial past#'ethfrac' ---> Linguistic fractionalization#'gdpcapl' ---> GDP per capita #'lpopl' ---> Population size #'lmtnest' ---> Mountanious terrain  #'regchg3' ---> Political instability#'anocl' ---> Anocracy #'oilpcl' ---> Oil production per capita#'ongoingwarl' ---> Ongoing war#npeaceyears #nspline1#nspline2#nspline3# --> Year-fixed effects, and standard errors clustered by country#'yearc'#'cowcode'#'gdpcap'#'oilpc'#'popavg'#'western'#'eeurop'#'lamerica'#'ssafrica'#'asia'#'nafrme'#'polity2'#'polity'#'anoc'#'democ'#'democl'#'groups'#'exclgrps'#'exclpop'#'ttlpop'#'discpop'#'pwrlpop'#'olppop'#'olpspop'#'jppop'#'sppop'#'dompop'#'monpop'#'maxexclpop'#'maxegippop'#'maxpop'#'newonset'#'newethonset'#'newhionset'#'newethhionset'#'onsetstatus'#'onsetstatus2'#'actoraim'#'actoraim2'#'ongoinghiwarl'#'newhionset2'#'newethonset2'#'warlfl'#'onsetfl'#'ethonsetfl'#'onsetfl2',#'ethonsetfl2'#'warstns2'#'warstns1'#'atwarnsl'#'npeaceyears'#'nspline1'#'nspline2'#'nspline3'#'hpeaceyears'#'hspline1'#'hspline2'#'hspline3'#'fpeaceyears'#'fspline1'#'fspline2'#'fspline3'#'speaceyears'#'sspline1'#'sspline2'#'sspline3'                     